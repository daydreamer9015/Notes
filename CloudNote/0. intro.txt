1. 소프트웨어 개발의 변화
    1) Software 1.0
        - Classic Stack
            - 개발자가 프로그래밍 언어로 직접 프로그램을 작성하고 컴파일하여 프로그램을 생성하는 전통적인 방식
            - DB -> 프로그램  Result
            - 절차적/객체지향 패러다임
               - C / C++, Java, Python, JavaScript etc
            
    2) Software 2.0
        - ML (Machine Learning)
            - 데이터를 기반으로 학습된 ML 모델 자체가 프로그램이 되어 결과를 생성하는 방식
            - 학습데이터 (csv...) -> ML 모델 -> Result (예측을 하거나 맞고 틀림의 결과를 내줌)
            - 학습된 가중치 기반 동작
            - 데이터 주도 최적화
            - 통계적 패턴 인식 및 추론
                - PyTorch, TensorFlow, scikit-learn,... (ML Model)
    
    3) Software 3.0
        - Prompt Engineering
            - 자연어(한국어, 영어...)로 AI 모델에게 작업을 지시하고 정의하여 원하는 결과물을 생성하는 방식
            - 사람 -> LLM(Large Language Model 대규모 언어 모델) -> 코드 생성, 컨텐츠 생성
            - 자연어 기반 지시 및 제어
            - LLM을 통한 코드/컨텐츠 생성
            - Prompt 최적화로 결과 조정
                - GPT-4o, Claud, LLaMA, Gemini, Midjourney...

    4) Software 4.0
        - AI Agent 기반 개발
            - 자율적인 AI Agent들이 협업(A to A)하여 복잡한 소프트웨어 시스템을 구축하는 방식 (2025 활발하게 진행 중)
            - ex) 개발 에이전트 -> 기획 에이전트 -> 테스트 에이전트 => 완성된 시스템
            - 자율적 AI 에이전트 협업 시스템
                - LangChain, RAG, Agent, AutoGPT, Claude-AI,...

2. 개발자
    1) 코딩만 하는 것이 아님
    2) 기술적으로 AI도구를 사용하여 코딩으로 문제(요구사항, 해결하는 기능)를 푸는 사람 : '내'가 메인이 되고 AI는 도구로만 사용해야 함.

3. 클린 코드, 좋은 코드
    1) 코드는 끊임없이 변화함
    2) 레거시 코드 (Legacy Code) - 업데이트가 되면 이전 코드는 모두 레거시 코드가 됨
        - (테스트되지 않은 채 유지보수되고 있는) 기존의 코드
        - (내가) 구현했지만 기억이 나지 않는 코드
    3) 레거시 코드의 비용
        - 유지보수 비용 증가
            - 해결하지 못한 설계 결함, 코드 문제
        - 호환성 문제
            - 새로운 기술 혹은 외부 시스템과의 연동 어려움
        - 보안 취약성
            - 라이브러리나 프레임워크 어려움

4. 페어프로그래밍 (Fair Programming)
    1) 두 개발자가 하나의 작업 스테이션에서 함께 코드를 작성하는 협업 기법
    2) 드라이버 : 실제 코드 작성 ('내'가 주도적으로 해야 함)
       네비게이터 : 코드를 리뷰하며 방향 제시 (AI의 도움을 받을 수 있음)