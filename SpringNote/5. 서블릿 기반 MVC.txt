1. JSP의 한계
    1) 비즈니스 로직과 View가 섞임 (유지보수 어려움)
    2) Java 코드와 HTML이 혼재 (가독성 저하)
    3) 디자이너와 협업 어려움

2. 권장사항
    1) MVC 패턴 사용 (Model - View - Controller)
    2) JSP는 View 역할만 담당
    3) 비즈니스 로직은 서블릿이나 Service 클래스에서 처리
    4) JSP는 JSTL, EL로 Java 코드 최소화

3. MVC 패턴 적용
    1) 서블릿은 컨트롤러로 사용, JSP는 뷰로 사용해서 MVC 패턴 사용하기
    2) 회원 등록
        - 회원 등록 폼 (컨트롤러)

4. Model View Controller
    1) 컨트롤러
        - HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행함
        - 뷰에 전달한 결과 데이터를 조회해서 모델에 담음
    2) 모델
        - 뷰에 출력할 데이터를 담아둠
    3) 뷰
        - 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중함

5. 시나리오
    1) 회원가입
        - 클라이언트 요청 (브라우저)
            - /servlet-mvc/members/new-form     GET 요청
        - MvcMemberFormServlet (Controller) : urlPatterns에 의해 등록되어 있고 ServletComponentScan으로 스캔되어 서비스 메서드 실행
            - service() 메서드 실행
            - Model 데이터 없음, 바로 forward() 준비
        - RequestDispatcher
            - "/WEB-INF/views/new-form.jsp" 서버 내부 전달
            - dispatcher.forward()
                - 다른 서블릿이나 JSP로 이동할 수 있는 기능임
                - 서버 내부에서 다시 호출이 발생함
                - /WEB-INF
                    - 이 경로 안에 JSP가 있으면 외부에서 직접 JSP를 호출할 수 없음
                    - 항상 컨트롤러를 통해서 JSP를 호출함
        - new-form.jsp로 이동 (View)
            - HTML 폼 생성
            - action
                - 절대 경로(/로 시작)가 아니라 상대 경로(/로 시작하지 않음)임
                    - 상대 경로를 사용하면 폼 전송 시 현재 URL이 속한 계층 경로 + save가 호출 됨
                - 현재 계층 경로 : /servlet-mvc/members/
                    - 결과 : /servlet-mvc/members/save
        - HTTP Response
            - 클라이언트에게 폼 화면 전송 (URL 변경 없음)
        - 회원 등록 폼
            - redirect vs forward
                - 리다이렉트
                    - 실제 클라이언트(웹 브라우저)에 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청함
                    - 클라이언트가 인지할 수 있고 URL 경로도 실제로 변경됨
                - 포워드
                    - 서버 내부에서 일어나는 호출
                    - 클라이언트가 전혀 인지하지 못함
    2) 회원 저장 처리
        - 클라이언트 (브라우저)
            - 폼 데이터 전송
                - POST /save
                    - username=홍길동
                      age=25
        -MvcMemberSaveServlet (Controller)
            - getParameter("username")
              getParameter("age")
            - new Member("홍길동", 25)
            - repository.save(member)
            - setAttribute("member", member); => "member"라는 이름으로 member 객체 호출
            - forward() => 데이터가 유지됨
        - MemberRepository 기능이 불려짐 (Model)
            - member.setId(++seq);
            - store.put(id, member);
            - return member
        - RequestDispatcher
        - save-result.jsp (View)
            - EL(${})로 데이터 읽기
            - HTML 문서 생성
        - HTTP Response
            - 저장 성공 화면 출력
            - /save => 기존 URL 유지
    3) 회원 목록 조회
        - 클라이언트 (브라우저)
            - GET 요청
            - /servlet-mvc/members
        - MvcMemberListServlet (Controller)
            - service() 시작(호출됨)
            - repository.findAll() 메서드
            - List<Member> members
            - setAttribute("members", list)
            - forward()
        - MemberRepository (Model)
            - store.values
            - return Arraylist
        - RequestDispatcher
        - members.jsp (View)
            - JSTL
                - c:forEach
            - EL
        - HTTP Response
            - HTML 회원목록 출력

6. MVC 패턴 - 한계
    1) 구조와 역할 명확하게 구분됨
    2) 코드가 깔끔하고 직관적임
    3) 컨트롤러는 중복 코드가 있고, 코드의 최적화 필요함
        - 포워드 중복
            - View로 이동하는 코드가 항상 중복 호출되어야 함
    4) 프런트 컨트롤러(Front Controller) 패턴 도입하면 위 문제 해결 가능
        - 입구를 하나로 둠